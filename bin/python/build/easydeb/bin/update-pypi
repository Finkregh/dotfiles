#!python
""" 
easy-deb autopackager for python modules

Copyright (C) 2005  Vincenzo Di Massa <hawk.it@tiscali.it

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,
USA.
"""

import glob, sys, os, shutil
from optparse import OptionParser

class UpdatePyPI:
    
    def __init__(self):
        self.available_dir='/var/lib/easydeb/python' + sys.version.split()[0][:-2] + '/pths/available/'
        self.installed_dir='/var/lib/easydeb/python' + sys.version.split()[0][:-2] + '/pths/installed/'
        self.pth_file=os.path.join("/usr", "lib", "python" + sys.version[:3], "site-packages", "easy_deb.pth")
        if not os.path.exists(self.installed_dir):
            os.makedirs(self.installed_dir)
        self.update_lists() 
        
    def update_lists(self):
        self.installed_f=glob.glob(self.installed_dir+'*')
        self.available_f=glob.glob(self.available_dir+'*')
        self.available = []
        self.installed = []
	
	tmp_inst=[]
        for file in  self.installed_f:
            try:
                f = open(file)
                self.installed.append( f.readline())
		tmp_inst.append(file)
	        f.close()
            except:
                pass
	self.installed_f=tmp_inst

        for file in self.available_f:
            f = open(file)
            self.available.append(f.readline())
            f.close()

    def add(self,module):
        print "Adding",module
        file=os.path.join(self.available_dir,module)
        if not os.path.exists(file):
            print module, "is not available"
        elif os.path.exists(os.path.join(self.installed_dir,module)):
            print module, "is not already installed"
        else:
            os.symlink(file, self.installed_dir+module)
	    print "Added."
            self.update_pth()
    
    def remove(self,module):
        print "Removing",module
        file=os.path.join(self.installed_dir,module)
        if not os.path.exists(file):
            print module, "is not installed"
        else:
            os.remove(file)
	    print "Removed."
            self.update_pth()
            
    def show(self):
        print "installed (%s)" % self.installed_dir
        for module in self.installed_f:
            print '-\t'+os.path.split(module)[1]
        print "\n\navailable (%s)" % self.available_dir
        for module in self.available_f:
            print '-\t'+os.path.split(module)[1]

    def update_pth(self):
        self.update_lists()
        f=open(self.pth_file,'w')
        for module in self.installed:
            f.write(module)
        f.close()

def main():
    parser = OptionParser("usage: %prog  (-a | -r | --add | --remove) module-name | show | update")
    
    parser.add_option("-a", "--add",
            action="store_true", dest="add", default=False,
            help="Add egg to sys.path")
    
    parser.add_option("-r", "--remove",
            action="store_true", dest="remove", default=False,
            help="Add egg to sys.path")
    
    (options, args) = parser.parse_args()
    
    update_pypi=UpdatePyPI()
    
    if len(args)==1:
        if args[0]=='show':
            update_pypi.show()
        elif args[0]=='update':
            update_pypi.update_pth()
        elif options.add:
            update_pypi.add(args[0])
        elif options.remove:
            update_pypi.remove(args[0])
        else:
            parser.print_help()
    else:
        parser.print_help()
            
if __name__=='__main__':
    main()

